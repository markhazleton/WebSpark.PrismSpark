// Auto generated by ./transform.js
using System.Text.RegularExpressions;
using WebSpark.PrismSpark;

namespace WebSpark.PrismSpark.Languages;

// From https://github.com/PrismJS/prism/blob/master/components/prism-go.js

/// <summary>
/// Provides syntax highlighting grammar definition for the Go programming language.
/// Supports Go syntax including comments, string literals, keywords, built-in functions, and operators.
/// </summary>
public class Go : IGrammarDefinition
{
    /// <summary>
    /// Defines the grammar rules for Go syntax highlighting.
    /// </summary>
    /// <returns>A Grammar object containing the token definitions for Go language syntax.</returns>
    public Grammar Define()
    {
        var grammar = new Grammar();

        grammar["comment"] = new GrammarToken[]
        {

        new(@"(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)", lookbehind: true, greedy: true),
        new(@"(^|[^\\:])\/\/.*", lookbehind: true, greedy: true),
        };
        grammar["char"] = new GrammarToken[]
        {

        new(@"'(?:\\.|[^'\\\r\n]){0,10}'", lookbehind: false, greedy: true),
        };
        grammar["string"] = new GrammarToken[]
        {

        new(@"(^|[^\\])""(?:\\.|[^""\\\r\n])*""|`[^`]*`", lookbehind: true, greedy: true),
        };
        grammar["keyword"] = new GrammarToken[]
        {

        new(@"\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b", lookbehind: false, greedy: false),
        };
        grammar["boolean"] = new GrammarToken[]
        {

        new(@"\b(?:_|false|iota|nil|true)\b", lookbehind: false, greedy: false),
        };
        grammar["function"] = new GrammarToken[]
        {

        new(@"\b\w+(?=\()", lookbehind: false, greedy: false),
        };
        grammar["number"] = new GrammarToken[]
        {

        new(new Regex(@"\b0(?:b[01_]+|o[0-7_]+)i?\b", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: false),
        new(new Regex(@"\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: false),
        new(new Regex(@"(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: false),
        };
        grammar["operator"] = new GrammarToken[]
        {

        new(@"[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.", lookbehind: false, greedy: false),
        };
        grammar["punctuation"] = new GrammarToken[]
        {

        new(@"[{}[\];(),.:]", lookbehind: false, greedy: false),
        };
        grammar["builtin"] = new GrammarToken[]
        {

        new(@"\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b", lookbehind: false, greedy: false),
        };

        return grammar;
    }
}
