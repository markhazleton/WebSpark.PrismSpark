// Auto generated by ./transform.js
using System.Text.RegularExpressions;
using WebSpark.PrismSpark;

namespace WebSpark.PrismSpark.Languages;

// From https://github.com/PrismJS/prism/blob/master/components/prism-python.js

/// <summary>
/// Provides syntax highlighting grammar definition for the Python programming language.
/// Supports Python syntax including string interpolation, comments, decorators, keywords, and built-in functions.
/// </summary>
public class Python : IGrammarDefinition
{
    /// <summary>
    /// Defines the grammar rules for Python syntax highlighting.
    /// </summary>
    /// <returns>A Grammar object containing the token definitions for Python language syntax.</returns>
    public Grammar Define()
    {
        var grammar = new Grammar();

        grammar["comment"] = new GrammarToken[]
        {

        new(@"(^|[^\\])#.*", lookbehind: true, greedy: true),
        };
        grammar["string-interpolation"] = new GrammarToken[]
        {

        new(new Regex(@"(?:f|fr|rf)(?:(""""""|''')[\s\S]*?\1|(""|')(?:\\.|(?!\2)[^\\\r\n])*\2)", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: true, inside: new Grammar
  {
      ["interpolation"] = new GrammarToken[]
      {

        new(@"((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}", lookbehind: true, greedy: false, inside: new Grammar
  {
      ["format-spec"] = new GrammarToken[]
      {

        new(@"(:)[^:(){}]+(?=\}$)", lookbehind: true, greedy: false),
      },
      ["conversion-option"] = new GrammarToken[]
      {

        new(@"![sra](?=[:}]$)", lookbehind: false, greedy: false, alias: new []{"punctuation" }),
      },
      Reset = null! /* see below */,
  }),
      },
      ["string"] = new GrammarToken[]
      {

        new(@"[\s\S]+", lookbehind: false, greedy: false),
      },
  }),
        };
        grammar["triple-quoted-string"] = new GrammarToken[]
        {

        new(new Regex(@"(?:[rub]|br|rb)?(""""""|''')[\s\S]*?\1", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: true, alias: new []{"string" }),
        };
        grammar["string"] = new GrammarToken[]
        {

        new(new Regex(@"(?:[rub]|br|rb)?(""|')(?:\\.|(?!\1)[^\\\r\n])*\1", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: true),
        };
        grammar["function"] = new GrammarToken[]
        {

        new(new Regex(@"((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()", RegexOptions.Compiled), lookbehind: true, greedy: false),
        };
        grammar["class-name"] = new GrammarToken[]
        {

        new(new Regex(@"(\bclass\s+)\w+", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: true, greedy: false),
        };
        grammar["decorator"] = new GrammarToken[]
        {

        new(new Regex(@"(^[\t ]*)@\w+(?:\.\w+)*", RegexOptions.Compiled | RegexOptions.Multiline), lookbehind: true, greedy: false, alias: new []{"annotation , punctuation" }, inside: new Grammar
  {
      ["punctuation"] = new GrammarToken[]
      {

        new(@"\.", lookbehind: false, greedy: false),
      },
  }),
        };
        grammar["keyword"] = new GrammarToken[]
        {

        new(@"\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b", lookbehind: false, greedy: false),
        };
        grammar["builtin"] = new GrammarToken[]
        {

        new(@"\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b", lookbehind: false, greedy: false),
        };
        grammar["boolean"] = new GrammarToken[]
        {

        new(@"\b(?:False|None|True)\b", lookbehind: false, greedy: false),
        };
        grammar["number"] = new GrammarToken[]
        {

        new(new Regex(@"\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)", RegexOptions.Compiled | RegexOptions.IgnoreCase), lookbehind: false, greedy: false),
        };
        grammar["operator"] = new GrammarToken[]
        {

        new(@"[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]", lookbehind: false, greedy: false),
        };
        grammar["punctuation"] = new GrammarToken[]
        {

        new(@"[{}[\];(),.:]", lookbehind: false, greedy: false),
        };
        grammar["string-interpolation"][0].Inside!["interpolation"][0].Inside!.Reset = grammar;

        return grammar;
    }
}
